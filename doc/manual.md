<div>
<!-- Generated by cxt.py from manual.cxt -->
<h1>The fngi programmer&#x27;s manual</h1><h2>Document conventions</h2>Text written in the <span>		fngi language			</span> is always <code>monospaced</code>. Text that concerns details that may not be relevant to a casual reader are <i>italicized</i>. </p><p><h2>Introduction</h2>The <span>		fngi language			</span> is an imperative, stack-based programming language. The semantics of the <span>		fngi language			</span> are described in terms of stack manipulation. When we say <span>			fngi				</span>, we are refering to the <span>		fngi language			</span>. The <span>		fngi environment		</span> is a REPL for the <span>		fngi interpreter		</span>.</p><p><h3><span>		Tokens				</span></h3>A <span>		fngi program			</span> is a program written in the <span>		fngi language			</span>. <span>		Fngi programs			</span> are composed of <span>			tokens				</span>. A <span>			token				</span> is the smallest unit of a <span>		fngi program			</span>. <span>		Tokens				</span> are typically <span>		evaluated			</span> from left to right and from top to bottom.</p><p></p><p>Whitespace is sometimes used to delineate between <span>			tokens				</span>, but has no semantic value.</p><p><h3><span>		Value tokens			</span></h3>A <span>		value token			</span> is a kind of <span>			token				</span>. When a <span>		value token			</span> is <span>		executed			</span>, the <span>			number				</span> represented by the <span>		value token			</span> is pushed onto the <span>		working stack			</span>. The <span>			token				</span> <span>		<code>1</code>				</span> is a <span>		value token			</span>. When <span>		executed			</span>, it pushes the <span>			number				</span> 1 onto the <span>		working stack			</span>.</p><p>Furthermore, <span>		<code>1 2</code>			</span> is a <span>		fngi program			</span>. It consists of two <span>		value tokens			</span>: <span>		<code>1</code>				</span> and <span>		<code>2</code>				</span>. When this <span>		fngi program			</span> is executed, the <span>			number				</span> 1 is pushed onto the <span>		working stack			</span>, then the <span>			number				</span> 2 is pushed onto the <span>		working stack			</span>. The <span>			tokens				</span> <span>		<code>1</code>				</span> and <span>		<code>2</code>				</span> could be separated by any whitespace to delineate between them.</p><p><span>		Value tokens			</span> can also be written in hexadecimal. The <span>			token				</span> <span>		<code>0x10</code>			</span> is a <span>		value token			</span>. When the <span>			token				</span> <span>		<code>0x10</code>			</span> is <span>		executed			</span>, the <span>			number				</span> 16 is pushed onto the <span>		working stack			</span>.</p><p><h3><span>	Function tokens			</span></h3>A <span>		function token			</span> is a kind of <span>			token				</span>. <span>	Function tokens			</span> in <span>			fngi				</span> are <span>		evaluated			</span> differently than functions in many other stack-based languages. Rather than being <span>		evaluated			</span> when they are encountered, <span>		function token			</span> <span>		evaluation			</span> is <span>			defered				</span> until after the next <span>			token				</span> is <span>		evaluated			</span>.</p><p>The <span>			token				</span> <span>		<code>+</code>				</span> is a <span>		function token			</span>. When <span>		<code>+</code>				</span> is <span>		executed			</span>, two <span>			numbers				</span> are popped from the <span>		working stack			</span>, then their sum is pushed to the <span>		working stack			</span>. The <span>		execution			</span> of the <span>		fngi program			</span> <span>	<code>1 + 2</code>			</span> performs the following operations in order:</p><p><ol><li value="1">Push the <span>			number				</span> 1 onto the <span>		working stack			</span>.</li><li value="2">Push the <span>			number				</span> 2 onto the <span>		working stack			</span> (the <span>		evaluation			</span> of <span>		<code>+</code>				</span> was <span>			defered				</span>).</li><li value="3">Finally, execute <span>		<code>+</code>				</span>.</li></ol>When this is performed, the <span>			number				</span> 3 is left on the <span>		working stack			</span>. Notice how this allows <span>		function tokens			</span> of arity 2 to be written in infix notation.</p><p>The token <span>		<code>*</code>				</span> is a <span>		function token			</span>. When <span>		<code>*</code>				</span> is <span>		executed			</span>, two <span>			numbers				</span> are popped from the <span>		working stack			</span>, then their product is pushed to the <span>		working stack			</span>. The <span>		execution			</span> of the <span>		fngi program			</span> <span>	<code>1 + 4 * 2</code>			</span> performs the following operations in order:</p><p><ol><li value="1">Push the <span>			number				</span> 1 onto the <span>		working stack			</span>.</li><li value="2">Push the <span>			number				</span> 2 onto the <span>		working stack			</span> (the <span>		evaluation			</span> of <span>		<code>+</code>				</span> was <span>			defered				</span>).</li><li value="3">Execute <span>		<code>+</code>				</span> leaving the <span>			number				</span> 3 on the <span>		working stack			</span>.</li><li value="4">Push the <span>			number				</span> 4 onto the <span>		working stack			</span> (the <span>		evaluation			</span> of <span>		<code>*</code>				</span> was <span>			defered				</span>).</li><li value="5">Execute <span>		<code>*</code>				</span> leaving the <span>			number				</span> 12 on the <span>		working stack			</span>.</li></ol>When multiple <span>		function tokens			</span> are <span>			defered				</span> successively, they are <span>		evaluated			</span> in the opposite order in which they were <span>			defered				</span>. The <span>		execution			</span> of the <span>		fngi program			</span> <span>	<code>1 2 + * 4</code>			</span> (a very ugly, but valid <span>		fngi program			</span>) performs the following operations in order:</p><p><ol><li value="1">Push the <span>			number				</span> 1 onto the <span>		working stack			</span>.</li><li value="2">Push the <span>			number				</span> 2 onto the <span>		working stack			</span>.</li><li value="3">Push the <span>			number				</span> 4 onto the <span>		working stack			</span> (the <span>		evaluation			</span> of <span>		<code>+</code>				</span> was <span>			defered				</span>, then the <span>		evaluation			</span> of <span>		<code>*</code>				</span> was <span>			defered				</span>).</li><li value="4">Execute <span>		<code>*</code>				</span>, leaving the <span>			number				</span> 8 on top of the <span>		working stack			</span>.</li><li value="5">Execute <span>		<code>+</code>				</span>, leaving the <span>			number				</span> 9 on top of the <span>		working stack			</span>.</li></ol><h3><span>		Immediate			</span> and <span>			delayed				</span> <span>		execution			</span></h3>When a <span>			token				</span> is <span>		evaluated			</span>, that <span>			token				</span> is either <span>		executed			</span> or added to a <span>		delay queue			</span> for later <span>		execution			</span>. We call this <span>		immediate			</span> and <span>			delayed				</span> <span>		execution			</span>, respectively.</p><p>When a <span>			token				</span> is <span>		executed			</span> <span>		immediate			</span>, <span>		execution			</span> occurs before the next <span>			token				</span> is <span>		evaluated			</span>.</p><p>When a <span>			token				</span> undergoes <span>			delayed				</span> <span>		execution			</span>, that <span>			token				</span> is added to a <span>		delay queue			</span>. To <span>			execute				</span> a <span>		delay queue			</span> is to <span>			execute				</span> the <span>			tokens				</span> in that <span>		delay queue			</span> in the order in which they were added. The <span>	global delay queue		</span> is the <span>		delay queue			</span> to which <span>			tokens				</span> are added by default. The <span>	global delay queue		</span> is <span>		executed			</span> after all <span>			tokens				</span> have been <span>		evaluated			</span>.</p><p><i>In the standard implementation, the </i><span>		delay queue			</span><i> is a </i><span>			spor				</span><i> buffer. </i><span>			Spor				</span><i> is the internal bytecode of the </i><span>		fngi language			</span><i>. In other implementations, the </i><span>		delay queue			</span><i> could be a native code buffer, or even a literal queue of </i><span>			fngi				</span><i> tokens. This is all implementation specific. For the purposes of documentation, we&#x27;ve chosen to simply call it a </i><span>		delay queue			</span><i>.</i></p><p>All of the examples of <span>			tokens				</span> and <span>		fngi programs			</span> that we have seen thus far have used <span>			delayed				</span> <span>		execution			</span>. <span>		Value tokens			</span> and <span>		function tokens			</span> use <span>			delayed				</span> <span>		execution			</span>. A deeper level of detail to our explanation of the behavior of the <span>		fngi program			</span> <span>		<code>1 2</code>			</span> would be:</p><p><ol><li value="1">The <span>			token				</span> <span>		<code>1</code>				</span> is <span>		evaluated			</span>. It undergoes <span>			delayed				</span> <span>		execution			</span> and is added to the <span>	global delay queue		</span>.</li><li value="2">The <span>			token				</span> <span>		<code>2</code>				</span> is <span>		evaluated			</span>. It undergoes <span>			delayed				</span> <span>		execution			</span> and is added to the <span>	global delay queue		</span>.</li><li value="3">Now that all <span>			tokens				</span> have been <span>		evaluated			</span>, we dequeue the <span>			token				</span> <span>		<code>1</code>				</span> from the <span>	global delay queue		</span>. The <span>			token				</span> <span>		<code>1</code>				</span> is <span>		executed			</span>, and the <span>			number				</span> 1 is pushed to the <span>		working stack			</span>.</li><li value="4">We dequeue the <span>			token				</span> <span>		<code>2</code>				</span> from the <span>	global delay queue		</span>. The token <span>		<code>2</code>				</span> is <span>		executed			</span>, and the <span>			number				</span> 2 is pushed to the <span>		working stack			</span>.</li></ol>To <span>			execute				</span> a <span>			token				</span> <span>		immediately			</span>, the <span>		<code>imm#</code>			</span> <span>			token				</span> is prepended to that <span>			token				</span>. For example, when the <span>		fngi program			</span> <span>	<code>2 imm#3 4</code>			</span> is <span>		executed			</span>, the following operations occur in order:</p><p><ol><li value="1">The <span>			token				</span> <span>		<code>2</code>				</span> is <span>		evaluated			</span>. It undergoes <span>			delayed				</span> <span>		execution			</span> and is added to the <span>	global delay queue		</span>.</li><li value="2">The <span>			token				</span> <span>		<code>imm#</code>			</span> causes the <span>			token				</span> <span>		<code>3</code>				</span> to be <span>		executed			</span> <span>		immediately			</span>. Prior to <span>		evaluating			</span> the <span>			token				</span> <span>		<code>4</code>				</span>, the <span>			number				</span> 3 is pushed to the <span>		working stack			</span>.</li><li value="3">The <span>			token				</span> <span>		<code>4</code>				</span> is <span>		evaluated			</span>. It undergoes <span>			delayed				</span> <span>		execution			</span> and is added to the <span>	global delay queue		</span>.</li><li value="4">The <span>			token				</span> <span>		<code>2</code>				</span> is dequeued from the <span>	global delay queue		</span> and <span>		executed			</span>. The <span>			number				</span> 2 is pushed to the <span>		working stack			</span>.</li><li value="5">The <span>			token				</span> <span>		<code>4</code>				</span> is dequeued from the <span>	global delay queue		</span> and <span>		executed			</span>. The <span>			number				</span> 4 is pushed to the <span>		working stack			</span>.</li></ol><h3><span>	Syntactic tokens		</span></h3>A <span>		syntactic token			</span> is a kind of <span>			token				</span>. Unlike <span>		value tokens			</span> and <span>		function tokens			</span>, <span>		syntactic tokens		</span> are <span>		executed			</span> <span>		immediately			</span> by default. <span>	Syntactic tokens		</span> can be built-in or user defined. The general purpose of <span>		syntactic tokens		</span> is to implement syntactic constructs. We have already seen an example of one <span>		syntactic token			</span>: the <span>		<code>imm#</code>			</span> <span>			token				</span>. The <span>		<code>imm#</code>			</span> <span>			token				</span> triggers <span>		immediate			</span> <span>		execution			</span> of the <span>			token				</span> which follows it.</p><p>The <span>			token				</span> <span>	<code>(</code>				</span> is a <span>		syntactic token			</span>. When the <span>			token				</span> <span>	<code>(</code>				</span> is <span>		executed			</span>, it <span>		evaluates			</span> all subsequent <span>			tokens				</span> until it encounters the <span>			token				</span> <span>	<code>)</code>				</span>. In effect, this causes all sequences of <span>			tokens				</span> which are parenthesized to be treated as a single <span>			token				</span> in a number of contexts.</p><p>For example, consider the <span>		fngi program			</span> <span>	<code>5 imm#(1 + 2)</code>		</span>. The <span>			token				</span> <span>		<code>5</code>				</span> undergoes <span>			delayed				</span> <span>		execution			</span>. The <span>			token				</span> <span>		<code>imm#</code>			</span> causes the token <span>	<code>(</code>				</span> to be <span>		executed			</span> <span>		immediately			</span>. The <span>			token				</span> <span>	<code>(</code>				</span> <span>		evaluates			</span> <span>	<code>1 + 2</code>			</span> (stopping at <span>	<code>)</code>				</span>) and triggers their <span>		immediate			</span> <span>		execution			</span> as well. The result is that the <span>			number				</span> 3 is pushed to the <span>		working stack			</span>, then the <span>			number				</span> 5 is pushed to the <span>		working stack			</span>.</p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></div>