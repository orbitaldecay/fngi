<div>
<!-- Generated by cxt.py from manual.cxt -->
<h1>The fngi programmer&#x27;s manual</h1>
<h2>Document conventions</h2>
Words and phrases with special meaning are 
<i>italicisized</i>
 the first time they are used. Fngi code is always 
<code>monospaced</code>
. 

</p><p>
<h2>Introduction</h2>
The 
<i>fngi language</i>
 is a stack-based programming language. The semantics of the fngi language are described in terms of stack manipulation. When we say 
<i>fngi</i>
, we are refering to the fngi langage. The 
<i>fngi environment</i>
 is a REPL for the 
<i>fngi interpreter</i>
.</p><p>
<h3>Tokens</h3>
A 
<i>fngi program</i>
 is a program written in the fngi language. Fngi programs are composed of 
<i>tokens</i>
. A token is the smallest unit of a fngi program. Tokens are typically 
<i>evaluated</i>
 from left to right and from top to bottom.</p><p>

</p><p>Whitespace is sometimes used to delineate between tokens, but has no semantic value.</p><p>
<h3>Value tokens</h3>
A 
<i>value token</i>
 is a kind of token. When a value token is executed, the number represented by the value token is pushed onto the 
<i>working stack</i>
. The token 
<code>1</code>
 is a value token. When executed, it pushes the number 1 onto the working stack.</p><p>Furthermore, 
<code>1 2</code>
 is a fngi program. It consists of two value tokens: 
<code>1</code>
 and 
<code>2</code>
. When this program is executed, the number 1 is pushed onto the working stack, then the number 2 is pushed onto the working stack. The tokens 
<code>1</code>
 and 
<code>2</code>
 could be separated by any whitespace to delineate between them.</p><p>Value tokens can also be written in hexadecimal. The token 
<code>0x10</code>
 is a token token. When 
<code>0x10</code>
 is executed, the number 16 is pushed onto the working stack.</p><p>
<h3>Function tokens</h3>
A 
<i>function token</i>
 is a kind of token. Function tokens in fngi are evaluated differently than functions in many other stack-based languages. Rather than being evaluated when they are encountered, function token evaluation is 
<i>deferred</i>
 until after the next token is evaluated.</p><p>The token 
<code>+</code>
 is a function token. When 
<code>+</code>
 is executed, two numbers are popped from the working stack, then their sum is pushed to the working stack. The execution of the program 
<code>1 + 2</code>
 performs the following operations in order:</p><p>
<ol><li value="1">Push the number 1 onto the working stack.</li><li value="2">Push the number 2 onto the working stack (the evaluation of <code>+</code> was deferred).</li><li value="3">Finally, execute <code>+</code>.</li></ol>
When this is performed, the number 3 is left on the working stack. Notice how this allows functions of arity 2 to be written in infix notation.</p><p>The token 
<code>*</code>
 is a function token. When 
<code>*</code>
 is executed, two numbers are popped from the working stack, then their product is pushed to the working stack. The execution of the program 
<code>1 + 2 * 4</code>
 performs the following operations in order:</p><p>
<ol><li value="1">Push the number 1 onto the working stack.</li><li value="2">Push the number 2 onto the working stack (the evaluation of <code>+</code> was deferred).</li><li value="3">Execute <code>+</code> leaving the number 3 on the working stack.</li><li value="4">Push the number 4 onto the working stack (the evaluation of <code>*</code> was deferred).</li><li value="5">Execute <code>*</code> leaving the number 12 on the working stack.</li></ol>
When multiple functions tokens are deferred successively, they are evaluated in the opposite order in which they were deferred. The execution of the program 
<code>1 2 + * 4</code>
 (a program which you would probably not want to write) performs the following operations in order:</p><p>
<ol><li value="1">Push the number 1 onto the working stack.</li><li value="2">Push the number 2 onto the working stack.</li><li value="3">Push the number 4 onto the working stack (the evaluation of <code>+</code> was deferred, then the evaluation of <code>*</code> was deferred).</li><li value="4">Execute <code>*</code>, leaving the number 8 on top of the working stack.</li><li value="5">Execute <code>+</code>, leaving the number 9 on top of the working stack.</li></ol>
<h3>Immediate and delayed execution</h3>
When a token is evaluated, that token is either executed or added to a 
<i>delay queue</i>
 for later execution. We call this 
<i>immediate</i>
 and 
<i>delayed</i>
 execution, respectively.</p><p>When a token is executed immediately, execution occurs before the next token is evaluated.</p><p>When a token undergoes delayed execution, that token is added to a delay queue. To execute a delay queue is to execute the tokens in that delay queue in the order in which they were added. The 
<i>global delay queue</i>
 is the delay queue to which tokens are added by default. The global delay queue is executed after all tokens have been evaluated.</p><p>All of the examples of tokens and fngi programs that we have seen thus far have used delayed execution. Value tokens and function tokens use delayed execution. A deeper level of detail to our explanation of the behavior of the fngi program 
<code>1 2</code>
 would be:</p><p>
<ol><li value="1">The token <code>1</code> is evaluated. It undergoes delayed execution and is added to the global delay queue.</li><li value="2">The token <code>2</code> is evaluated. It undergoes delayed execution and is added to the global delay queue.</li><li value="3">Now that all tokens have been evaluated, we dequeue the token <code>1</code> from the global delay queue. The token <code>1</code> is executed, and the number 1 is pushed to the working stack.</li><li value="4">We dequeue the token <code>2</code> from the global delay queue. The token <code>2</code> is executed, and the number 2 is pushed to the working stack.</li></ol>
To execute a token immediately, the 
<code>imm#</code>
 token is prepended to that token. For example, when the program 
<code>2 imm#3 4</code>
 is run, the following operations occur in order:</p><p>
<ol><li value="1">The token <code>2</code> is evaluated. It undergoes delayed execution and is added to the global delay queue.</li><li value="2">The token <code>imm#</code> causes the token <code>3</code> to be executed immediately. Prior to evaluating the token <code>4</code>, the number 3 is pushed to the working stack.</li><li value="3">The token <code>4</code> is evaluated. It undergoes delayed execution and is added to the global delay queue.</li><li value="4">The token <code>2</code> is dequeued from the global delay queue and executed. The number 2 is pushed to the working stack.</li><li value="5">The token <code>4</code> is dequeued from the global delay queue and executed. The number 4 is pushed to the working stack.</li></ol>
<h3>Syntactic tokens</h3>
A 
<i>syntactic token</i>
 is a kind of token. Unlike value tokens and function tokens, syntactic tokens are executed immediately by default. Syntactic tokens can be built-in or user defined. The general purpose of syntactic tokens is to implement syntactic constructs. We have already seen an example of one syntactic token: the 
<code>imm#</code>
 token. The 
<code>imm#</code>
 token triggers immediate execution of the token which follows it.</p><p>The token 
<code>(</code>
 is a syntactic token. When the token 
<code>(</code>
 is executed, it evaluates all subsequent tokens until it encounters the token 
<code>)</code>
. In effect, this causes all sequences of tokens which are parenthesized to be treated as a single token in a number of contexts.</p><p>For example, consider the program 
<code>5 imm#(1 + 2)</code>
. The token 
<code>5</code>
 undergoes delayed execution. The token 
<code>imm#</code>
 causes the token 
<code>(</code>
 to be executed immediately. The token 
<code>(</code>
 evaluates 
<code>1 + 2</code>
 (stopping at 
<code>)</code>
) and triggers their immediate execution as well. The result is that the number 3 is pushed to the working stack, then the number 5 is pushed to the working stack.</p><p>

</div>
