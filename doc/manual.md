<div>
<!-- Generated by cxt.py from manual.cxt -->
<h1>The fngi manual</h1>
<h2>Document conventions</h2>
Words and phrases with special meaning are 
<i>italicisized</i>
 the first time they are used. Fngi code is always 
<code>monospaced</code>
. 

</p><p>
<h2>Introduction</h2>
The 
<i>fngi language</i>
 is a stack-based programming language. The semantics of the fngi language are described in terms of stack manipulation. When we say 
<i>fngi</i>
, we are refering to the fngi langage. The 
<i>fngi environment</i>
 is a REPL for the 
<i>fngi interpreter</i>
.</p><p>
<h3>Tokens</h3>
A 
<i>fngi program</i>
 is a program written in the fngi language. Fngi programs are composed of 
<i>tokens</i>
. A token is the smallest unit of a fngi program. tokens are typically 
<i>evaluated</i>
 from left to right and from top to bottom. After a token is evaluated, it is 
<i>executed</i>
.</p><p>

</p><p>Whitespace is sometimes used to delineate between tokens, but has no semantic value.</p><p>
<h3>Value tokens</h3>
A 
<i>value token</i>
 is a kind of token. When a value token is executed, the number represented by the value token is pushed onto the 
<i>working stack</i>
. The token 
<code>1</code>
 is a value token. When executed, it pushes the number 1 onto the working stack.</p><p>Furthermore, 
<code>1 2</code>
 is a fngi program. It consists of two value tokens: 
<code>1</code>
 and 
<code>2</code>
. When this program is executed, the number 1 is pushed onto the working stack, then the number 2 is pushed onto the working stack. The tokens 
<code>1</code>
 and 
<code>2</code>
 could be separated by any whitespace to delineate between them.</p><p>Value tokens can also be written in hexadecimal. The token 
<code>0x10</code>
 is a token token. When 
<code>0x10</code>
 is executed, the number 16 is pushed onto the working stack.</p><p>
<h3>Function tokens</h3>
A 
<i>function token</i>
 is a kind of token. Function tokens in fngi are evaluated differently than functions in many other stack-based languages. Rather than being evaluated when they are encountered, function token evaluation is 
<i>deferred</i>
 until after the next token is evaluated.</p><p>The token 
<code>+</code>
 is a function token. When 
<code>+</code>
 is executed, two numbers are popped from the working stack, then their sum is pushed to the working stack. The execution of the program 
<code>1 + 2</code>
 performs the following operations in order:</p><p>
<ol><li value="1">Push the number 1 onto the working stack.</li><li value="2">Push the number 2 onto the working stack (the evaluation of <code>+</code> was deferred).</li><li value="3">Finally, execute <code>+</code>.</li></ol>
When this is performed, the number 3 is left on the working stack. Notice how this allows functions of arity 2 to be written in infix notation.</p><p>The token 
<code>*</code>
 is a function token. When 
<code>*</code>
 is executed, two numbers are popped from the working stack, then their product is pushed to the working stack. The execution of the program 
<code>1 + 2 * 4</code>
 performs the following operations in order:</p><p>
<ol><li value="1">Push the number 1 onto the working stack.</li><li value="2">Push the number 2 onto the working stack (the evaluation of <code>+</code> was deferred).</li><li value="3">Execute <code>+</code> leaving the number 3 on the working stack.</li><li value="4">Push the number 4 onto the working stack (the evaluation of <code>*</code> was deferred).</li><li value="5">Execute <code>*</code> leaving the number 12 on the working stack.</li></ol>
When multiple functions tokens are deferred successively, they are evaluated in the opposite order in which they were deferred. The execution of the program 
<code>1 2 + * 4</code>
 (a program which you would probably not want to write) performs the following operations in order:</p><p>
<ol><li value="1">Push the number 1 onto the working stack.</li><li value="2">Push the number 2 onto the working stack.</li><li value="3">Push the number 4 onto the working stack (the evaluation of <code>+</code> was deferred, then the evaluation of <code>*</code> was deferred).</li><li value="4">Execute <code>*</code>, leaving the number 8 on top of the working stack.</li><li value="5">Execute <code>+</code>, leaving the number 9 on top of the working stack.</li></ol>
<h3>Syntactic function tokens</h3>

</p><p>A 
<i>syntactic function token</i>
 is a kind of token.</p><p>When any token is evaluated, it is, at some point, executed. Execution is either 
<i>immediate</i>
 or 
<i>delayed</i>
. When execution is immediate, the token is executed before the next token is evaluated. When execution is delayed, the token is executed after all tokens in the program have been evaluated. After all tokens in the program have been evaluated, delayed tokens are executed in the order in which they were evaluated.</p><p>

</p><p>All of the examples of tokens and fngi programs that we have seen thus far have used delayed execution. Syntactic function tokens always use immediate execution.</p><p>

</div>
