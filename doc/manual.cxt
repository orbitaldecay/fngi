[h1]The fngi programmer's manual[/]

[h2]1. Document conventions[/]
[+]
1. Text written in the @FngiLanguage is [c]monospaced[c].
2. The word @ALWAYS implies the sentence is always true; if the sentence is ever false then we have made a mistake.
3. The word @USUALLY implies the sentence is assumed to be true. We will write when it is false.
4. The word @SOMETIMES implies the sentence is assumed to be false. We will write when it is true.
5. The word @NEVER implies sentence is never true. If the sentence is ever true then we have made a mistake.
[/]

[!]Text in developer comments is for authors.[/] 

[h2]2. Introduction[/]

The @FngiLanguage is an imperative, stack-based programming language. The purpose of this manual is to explain the @Meaning of @FngiPrograms.

[h3]3. @FngiProgramsCap[/]

[+]
1. A @FngiProgram is a @Sequence of @Tokens.
2. The @Meaning of a @FngiProgram is the effect of @Executing the @FngiProgram.
3. To @Execute a @FngiProgram is to @Parse all @Tokens in the @FngiProgram in order.
[/]

[h3]4. @TokensCap[/]

[+]
1. To @Parse a @Token is to determine when it should be @Evaluated.
2. @TokensCap are @USUALLY @Evaluated when they are @Parsed.
3. To @Evaluate a @Token is to determine when it should be @Executed.
4. @TokensCap are @USUALLY @Executed either when they are @Evaluated, or after all @Tokens in the @FngiProgram have been @Evaluated.
5. To @Execute a @Token is to do what the @Token @Means.
6. @WhiteSpaceCap is @SOMETIMES used to separate @Tokens.

[!]6. @TokensCap @NEVER contain @WhiteSpace.[/]
[!]7. @WhiteSpaceCap @NEVER has @Meaning.[/]
[/]

[h3]5. @ValueTokensCap[/]

[+]
1. A @ValueToken is a kind of @Token.
2. @ValueTokensCap represent @Numbers.
3. The @Meaning of a @ValueToken is to @Push the @Number which is represented by the @ValueToken to the @WorkingStack.
4. @ValueTokensCap must be separated by @WhiteSpace when they occur @Sequentially in a @FngiProgram (4.4). 

[/]

[h3]6. @ValueTokenCap examples[/]

[+]
1. The @Token @ProgramOne is a @ValueToken. It @Means @Push the @Number 1 to the @WorkingStack.
2. The @Token @ProgramTwelve is a@ValueToken. It @Means @Push the @Number 12 to the @WorkingStack.
3. The @Token @ProgramHex is a @ValueToken. It @Means @Push the @Number 16 to the @WorkingStack.
4. The @FngiProgram @ProgramOneTwo is made of the @ValueTokens @ProgramOne and @ProgramTwo. These @ValueTokens are separated by @WhiteSpace. The @FngiProgram @ProgramOneTwo @Means @Push the @Number 1 to the @WorkingStack, then @Push the @Number 2 to the @WorkingStack. 
[/]

[h3]7. @FunctionTokensCap[/]

[+]
1. A @FunctionToken is a kind of @Token.
2. @DeferedCap @Evaluation is to @Evaluate after the next @Token in the @FngiProgram has been @Evaluated. 
3. @FunctionTokensCap are @NEVER @Evaluated when they are @Parsed (4.1).
4. @FunctionTokensCap @ALWAYS use @Defered @Evaluation.
[/]

[h3]8. @FunctionTokenCap examples[/]

The @Token @ProgramAdd is a @FunctionToken. The @Token @ProgramAdd @Means @Pull two @Numbers from the @WorkingStack, then @Push their sum to the @WorkingStack. The @FngiProgram @ProgramOnePlusTwo @Means

[+]
1. @PushCap the @Number 1 to the @WorkingStack.
2. @PushCap the @Number 2 to the @WorkingStack (the @Evaluation of @ProgramAdd was @Defered).
3. Execute @ProgramAdd. Now, the @Number 3 is on the @WorkingStack
[/]

The token @ProgramMul is a @FunctionToken. The @Token @ProgramMul @Means @Pull two @Numbers from the @WorkingStack, then @Push their sum to the @WorkingStack. The @FngiProgram @Program1Add2Mul4 @Means

[+]
1. @PushCap the @Number 1 to the @WorkingStack.
2. @PushCap the @Number 2 to the @WorkingStack (the @Evaluation of @ProgramAdd was @Defered).
3. Execute @ProgramAdd. Now, the @Number 3 is on the @WorkingStack.
4. @PushCap the @Number 4 to the @WorkingStack (the @Evaluation of @ProgramMul was @Defered).
5. Execute @ProgramMul. Now, the @Number 12 on the @WorkingStack.
[/]

When @FunctionTokens are @Defered @Sequentially, they are @Evaluated in the order opposite to which they were @Defered. The @FngiProgram @ProgramOneTwoAddMulFour @Means

[+]
1. @PushCap the @Number 1 to the @WorkingStack.
2. @PushCap the @Number 2 to the @WorkingStack.
3. @PushCap the @Number 4 to the @WorkingStack (the @Evaluation of @ProgramAdd was @Defered, then the @Evaluation of @ProgramMul was @Defered).
4. Execute @ProgramMul. Now, the @Number 8 is on the @WorkingStack.
5. Execute @ProgramAdd. Now, the @Number 9 is on the @WorkingStack.
[/]

[h3]9. @ImmediateCap and @Delayed @Execution[/]

When a @Token is @Evaluated, that @Token is either @Executed or added to a @DelayQueue for later @Execution. We call this @Immediate and @Delayed @Execution, respectively.

When a @Token is @Executed @Immediately, @Execution occurs before the next @Token is @Parsed.

When a @Token undergoes @Delayed @Execution, that @Token is added to a @DelayQueue. The @GlobalDelayQueue is the @DelayQueue to which @Tokens are @USUALLY added. To @Execute a @DelayQueue is to @Execute the @Tokens in that @DelayQueue in the order in which they were added. The @GlobalDelayQueue is @Executed after all @Tokens have been @Evaluated.

[!]In the standard implementation, the @DelayQueue is a @Spor buffer. @SporCap is the internal bytecode of the @FngiLanguage. In other implementations, the @DelayQueue could be a native code buffer, or even a literal queue of @Fngi tokens. This is all implementation specific. For the purposes of documentation, we've chosen to simply call it a @DelayQueue.[/]

When @Tokens are @Evaluated, @Execution is @USUALLY delayed. A deeper level of detail to our explanation of the behavior of the @FngiProgram @ProgramOneTwo would be:

[+]
1. The @Token @ProgramOne is @Evaluated. It undergoes @Delayed @Execution and is added to the @GlobalDelayQueue.
2. The @Token @ProgramTwo is @Evaluated. It undergoes @Delayed @Execution and is added to the @GlobalDelayQueue.
3. Now that all @Tokens have been @Evaluated, we dequeue the @Token @ProgramOne from the @GlobalDelayQueue. The @Token @ProgramOne is @Executed, and the @Number 1 is pushed to the @WorkingStack.
4. We dequeue the @Token @ProgramTwo from the @GlobalDelayQueue. The token @ProgramTwo is @Executed, and the @Number 2 is pushed to the @WorkingStack.
[/]

To @Execute a @Token @Immediately, the @ProgramImm @Token is prepended to that @Token. The @ProgramImm @Token is @ALWAYS @Executed @Immediately. For example, when the @FngiProgram @ProgramTwoImmThreeFour is @Executed, the following operations occur in order:

[+]
1. The @Token @ProgramTwo is @Evaluated. It undergoes @Delayed @Execution and is added to the @GlobalDelayQueue.
2. The @Token @ProgramImm is @Executed @Immediately. It causes the @Token @ProgramThree to be @Executed @Immediately. Prior to @Parsing the @Token @ProgramFour, the @Number 3 is pushed to the @WorkingStack.
3. The @Token @ProgramFour is @Evaluated. It undergoes @Delayed @Execution and is added to the @GlobalDelayQueue.
4. The @Token @ProgramTwo is dequeued from the @GlobalDelayQueue and @Executed. The @Number 2 is pushed to the @WorkingStack.
5. The @Token @ProgramFour is dequeued from the @GlobalDelayQueue and @Executed. The @Number 4 is pushed to the @WorkingStack.
[/]

[h3]10. @SyntacticTokensCap[/]

A @SyntacticToken is a kind of @Token. @SyntacticTokensCap are @ALWAYS @Executed @Immediately. @SyntacticTokensCap can be built-in or user defined. The general purpose of @SyntacticTokens is to implement syntactic constructs. We have already seen an example of one @SyntacticToken: the @ProgramImm @Token. The @ProgramImm @Token triggers @Immediate @Execution of the @Token which follows it.

The @Token @ProgramLeftParen is a @SyntacticToken. When the @Token @ProgramLeftParen is @Executed, it @Evaluates all subsequent @Tokens until it encounters the @Token @ProgramRightParen. In effect, this causes all sequences of @Tokens which are parenthesized to be treated as a single @Token in a number of contexts.

For example, consider the @FngiProgram @ProgramParenExample. The @Token @ProgramFive undergoes @Delayed @Execution. The @Token @ProgramImm causes the token @ProgramLeftParen to be @Executed @Immediately. The @Token @ProgramLeftParen @Evaluates @ProgramOnePlusTwo (stopping at @ProgramRightParen) and triggers their @Immediate @Execution as well. The result is that the @Number 3 is pushed to the @WorkingStack, then the @Number 5 is pushed to the @WorkingStack.

[!]Explain [c]()[c], [c]+(1 2)[c] and [c]1 2 +()[c] in this section. Correct grammar and spelling mistakes using automated checker.[/]

[!] glossary -------------------------------------------------	[/]


[t set=ALWAYS]			[i]always[i]			[/]
[t set=USUALLY]			[i]usually[i]			[/]
[t set=SOMETIMES]		[i]sometimes[i]			[/]
[t set=NEVER]			[i]never[i]			[/]

[!] fngi related [/]

[t set=Fngi]			fngi				[/]
[t set=FngiLanguage]		fngi language			[/]
[t set=FngiEnvironment]		fngi environment		[/]
[t set=FngiInterpreter]		fngi interpreter		[/]

[t set=FngiProgramsCap]		Fngi programs			[/]
[t set=FngiProgram]		fngi program			[/]
[t set=FngiPrograms]		fngi programs			[/]

[!] token names [/]

[t set=TokensCap]		Tokens				[/]
[t set=Token]			token				[/]
[t set=Tokens]			tokens				[/]

[t set=ValueTokenCap]		Value token			[/]
[t set=ValueTokensCap]		Value tokens			[/]
[t set=ValueToken]		value token			[/]
[t set=ValueTokens]		value tokens			[/]

[t set=FunctionTokenCap]	Function token			[/]
[t set=FunctionTokensCap]	Function tokens			[/]
[t set=FunctionToken]		function token			[/]
[t set=FunctionTokens]		function tokens			[/]

[t set=SyntacticTokensCap]	Syntactic tokens		[/]
[t set=SyntacticToken]		syntactic token			[/]
[t set=SyntacticTokens]		syntactic tokens		[/]

[!] evaluation and execution, and parsed [/]

[t set=Parse]			parse				[/]
[t set=Parsed]			parsed				[/]
[t set=Parsing]			parsing				[/]

[t set=Evaluate]		evaluate			[/]
[t set=Evaluated]		evaluated			[/]
[t set=Evaluating]		evaluating			[/]
[t set=Evaluation]		evaluation			[/]
[t set=Evaluates]		evaluates			[/]

[t set=Execute]			execute				[/]
[t set=Executed]		executed			[/]
[t set=Execution]		execution			[/]
[t set=Executing]		executing			[/]

[!] defered, delayed, immediate [/]

[t set=DeferedCap]		Defered				[/]
[t set=Defered]			defered				[/]
[t set=Delayed]			delayed				[/]
[t set=ImmediateCap]		Immediate			[/]
[t set=Immediate]		immediate			[/]
[t set=Immediately]		immediately			[/]

[!] data structures and data types [/]

[t set=WorkingStack]		working stack			[/]
[t set=Push]			push				[/]
[t set=PushCap]			Push				[/]
[t set=Pull]			pull				[/]
[t set=Number]			number				[/]
[t set=Numbers]			numbers				[/]
[t set=DelayQueue]		delay queue			[/]
[t set=GlobalDelayQueue]	global delay queue		[/]

[!] spor [/]

[t set=Spor]			spor				[/]
[t set=SporCap]			Spor				[/]

[!] misc [/]

[t set=Sequence]		sequence			[/]
[t set=Sequentially]		seqentially			[/]
[t set=Subsequent]		subsequent			[/]
[t set=WhiteSpace]		white space			[/]
[t set=WhiteSpaceCap]		White space			[/]
[t set=Means]			means				[/]
[t set=Meaning]			meaning				[/]

[!] example code ---------------------------------------------	[/]

[t set=ProgramOne]		[c]1[c]				[/]
[t set=ProgramTwo]		[c]2[c]				[/]
[t set=ProgramOneTwo]		[c]1 2[c]			[/]
[t set=ProgramTwelve]		[c]12[c]			[/]
[t set=ProgramHex]		[c]0x10[c]			[/]
[t set=ProgramAdd]		[c]+[c]				[/]
[t set=ProgramOnePlusTwo]	[c]1 + 2[c]			[/]
[t set=ProgramMul]		[c]*[c]				[/]
[t set=Program1Add2Mul4]	[c]1 + 2 * 4[c]			[/]
[t set=ProgramOneTwoAddMulFour]	[c]1 2 + * 4[c]			[/]
[t set=ProgramImm]		[c]imm#[c]			[/]
[t set=ProgramTwoImmThreeFour]	[c]2 imm#3 4[c]			[/]
[t set=ProgramImmThree]		[c]imm#3[c]			[/]
[t set=ProgramThree]		[c]3[c]				[/]
[t set=ProgramFour]		[c]4[c]				[/]
[t set=ProgramFive]		[c]5[c]				[/]
[t set=ProgramParenExample]	[c]5 imm#(1 + 2)[c]		[/]
[t set=ProgramLeftParen]	[c]([c]				[/]
[t set=ProgramRightParen]	[c])[c]				[/]
