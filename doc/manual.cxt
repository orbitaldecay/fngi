[h1]The fngi programmer's manual[/]

[h2]Document conventions[/]

Text written in the @FngiLanguage is [c]monospaced[c]. Words in [b]bold[b] have special meaning:

[+]
* The word @ALWAYS means the sentence is always true; if the sentence is ever false then we have made a mistake.
* The word @USUALLY means the sentence is assumed to be true. We will write when it is false.
* The word @SOMETIMES means the sentence is assumed to be false. We will write when it is true.
* The word @NEVER means the sentence is never true. If the sentence is ever true then we have made a mistake.
[/]

[!]Text in developer comments is for authors.[/] 

[h2]Introduction[/]

The @FngiLanguage is an imperative, stack-based programming language.

[h3]@TokensCap[/]

A @FngiProgram is a program written in the @FngiLanguage. @FngiProgramsCap are made of @Tokens. @TokensCap are @Parsed sequentially. @TokensCap are @USUALLY @Evaluated when they are parsed.

[!]I am writing this for the purposes of explaining how fngi programs are executed. From that perspective, we are interested in explaining the order of execution of tokens. Let me know if you think this is at all unclear.[/]

White space is @SOMETIMES used to separate @Tokens, but white space has no meaning.

[h3]@ValueTokensCap[/]

A @ValueToken is a kind of @Token. When a @ValueToken is @Executed, the @Number represented by the @ValueToken is pushed to the @WorkingStack. When two @ValueTokens occur sequentially in a @FngiProgram, they should be separated by white space.

[+]
* The @Token @ProgramOne is a @ValueToken. When this @Token is @Executed, the @Number 1 is pushed to the @WorkingStack.
* The @FngiProgram @ProgramOneTwo is made of the @ValueToken @ProgramOne and the @ValueToken @ProgramTwo. These @ValueTokens are separated by white space. When this @FngiProgram is executed, the @Number 1 is pushed to the @WorkingStack, then the @Number 2 is pushed to the @WorkingStack. 
* The @FngiProgram @ProgramTwelve is made of one @ValueToken. When this @FngiProgram is @Executed, the @Number 12 is pushed to the @WorkingStack.
* The @Token @ProgramHex is a @ValueToken. When this @Token is @Executed, the @Number 16 is pushed to the @WorkingStack.
[/]

[h3]@FunctionTokensCap[/]

A @FunctionToken is a kind of @Token. @FunctionTokensCap are not @Evaluated when they are @Parsed. @FunctionTokensCap are @Evaluated after the next @Token is @Evaluated. We call this @Defered @Evaluation.

The @Token @ProgramAdd is a @FunctionToken. When @ProgramAdd is @Executed, two @Numbers are popped from the @WorkingStack, then their sum is pushed to the @WorkingStack. The @Execution of the @FngiProgram @ProgramOnePlusTwo performs the following operations in order:

[+]
1. Push the @Number 1 on the @WorkingStack.
2. Push the @Number 2 on the @WorkingStack (the @Evaluation of @ProgramAdd was @Defered).
3. Execute @ProgramAdd and leave 3 on the @WorkingStack.
[/]

The token @ProgramMul is a @FunctionToken. When @ProgramMul is @Executed, two @Numbers are popped from the @WorkingStack, then their product is pushed to the @WorkingStack. The @Execution of the @FngiProgram @Program1Add2Mul4 performs the following operations in order:

[+]
1. Push the @Number 1 on the @WorkingStack.
2. Push the @Number 2 on the @WorkingStack (the @Evaluation of @ProgramAdd was @Defered).
3. Execute @ProgramAdd and leave the @Number 3 on the @WorkingStack.
4. Push the @Number 4 on the @WorkingStack (the @Evaluation of @ProgramMul was @Defered).
5. Execute @ProgramMul and leave the @Number 12 on the @WorkingStack.
[/]

When multiple @FunctionTokens are @Defered sequentially, they are @Evaluated in the opposite order in which they were @Defered. The @Execution of the @FngiProgram @ProgramOneTwoAddMulFour (a very ugly, but valid @FngiProgram) performs the following operations in order:

[+]
1. Push the @Number 1 on the @WorkingStack.
2. Push the @Number 2 on the @WorkingStack.
3. Push the @Number 4 on the @WorkingStack (the @Evaluation of @ProgramAdd was @Defered, then the @Evaluation of @ProgramMul was @Defered).
4. Execute @ProgramMul and leave the @Number 8 on the @WorkingStack.
5. Execute @ProgramAdd and leave the @Number 9 on the @WorkingStack.
[/]

[h3]@ImmediateCap and @Delayed @Execution[/]

When a @Token is @Evaluated, that @Token is either @Executed or added to a @DelayQueue for later @Execution. We call this @Immediate and @Delayed @Execution, respectively.

When a @Token is @Executed @Immediately, @Execution occurs before the next @Token is @Parsed.

When a @Token undergoes @Delayed @Execution, that @Token is added to a @DelayQueue. The @GlobalDelayQueue is the @DelayQueue to which @Tokens are @USUALLY added. To @Execute a @DelayQueue is to @Execute the @Tokens in that @DelayQueue in the order in which they were added. The @GlobalDelayQueue is @Executed after all @Tokens have been @Evaluated.

[!]In the standard implementation, the @DelayQueue is a @Spor buffer. @SporCap is the internal bytecode of the @FngiLanguage. In other implementations, the @DelayQueue could be a native code buffer, or even a literal queue of @Fngi tokens. This is all implementation specific. For the purposes of documentation, we've chosen to simply call it a @DelayQueue.[/]

When @Tokens are @Evaluated, @Execution is @USUALLY delayed. A deeper level of detail to our explanation of the behavior of the @FngiProgram @ProgramOneTwo would be:

[+]
1. The @Token @ProgramOne is @Evaluated. It undergoes @Delayed @Execution and is added to the @GlobalDelayQueue.
2. The @Token @ProgramTwo is @Evaluated. It undergoes @Delayed @Execution and is added to the @GlobalDelayQueue.
3. Now that all @Tokens have been @Evaluated, we dequeue the @Token @ProgramOne from the @GlobalDelayQueue. The @Token @ProgramOne is @Executed, and the @Number 1 is pushed to the @WorkingStack.
4. We dequeue the @Token @ProgramTwo from the @GlobalDelayQueue. The token @ProgramTwo is @Executed, and the @Number 2 is pushed to the @WorkingStack.
[/]

To @Execute a @Token @Immediately, the @ProgramImm @Token is prepended to that @Token. The @ProgramImm @Token is @ALWAYS @Executed @Immediately. For example, when the @FngiProgram @ProgramTwoImmThreeFour is @Executed, the following operations occur in order:

[+]
1. The @Token @ProgramTwo is @Evaluated. It undergoes @Delayed @Execution and is added to the @GlobalDelayQueue.
2. The @Token @ProgramImm causes the @Token @ProgramThree to be @Executed @Immediately. Prior to @Parsing the @Token @ProgramFour, the @Number 3 is pushed to the @WorkingStack.
3. The @Token @ProgramFour is @Evaluated. It undergoes @Delayed @Execution and is added to the @GlobalDelayQueue.
4. The @Token @ProgramTwo is dequeued from the @GlobalDelayQueue and @Executed. The @Number 2 is pushed to the @WorkingStack.
5. The @Token @ProgramFour is dequeued from the @GlobalDelayQueue and @Executed. The @Number 4 is pushed to the @WorkingStack.
[/]

[h3]@SyntacticTokensCap[/]

A @SyntacticToken is a kind of @Token. @SyntacticTokensCap are @ALWAYS @Executed @Immediately. @SyntacticTokensCap can be built-in or user defined. The general purpose of @SyntacticTokens is to implement syntactic constructs. We have already seen an example of one @SyntacticToken: the @ProgramImm @Token. The @ProgramImm @Token triggers @Immediate @Execution of the @Token which follows it.

The @Token @ProgramLeftParen is a @SyntacticToken. When the @Token @ProgramLeftParen is @Executed, it @Evaluates all subsequent @Tokens until it encounters the @Token @ProgramRightParen. In effect, this causes all sequences of @Tokens which are parenthesized to be treated as a single @Token in a number of contexts.

For example, consider the @FngiProgram @ProgramParenExample. The @Token @ProgramFive undergoes @Delayed @Execution. The @Token @ProgramImm causes the token @ProgramLeftParen to be @Executed @Immediately. The @Token @ProgramLeftParen @Evaluates @ProgramOnePlusTwo (stopping at @ProgramRightParen) and triggers their @Immediate @Execution as well. The result is that the @Number 3 is pushed to the @WorkingStack, then the @Number 5 is pushed to the @WorkingStack.

[!]Explain [c]()[c], [c]+(1 2)[c] and [c]1 2 +()[c] in this section. Correct grammar and spelling mistakes using automated checker.[/]

[!] glossary -------------------------------------------------	[/]


[t set=ALWAYS]			[b]always[b]			[/]
[t set=USUALLY]			[b]usually[b]			[/]
[t set=SOMETIMES]		[b]sometimes[b]			[/]
[t set=NEVER]			[b]never[b]			[/]

[!] fngi related [/]

[t set=Fngi]			fngi				[/]
[t set=FngiLanguage]		fngi language			[/]
[t set=FngiEnvironment]		fngi environment		[/]
[t set=FngiInterpreter]		fngi interpreter		[/]

[t set=FngiProgramsCap]		Fngi programs			[/]
[t set=FngiProgram]		fngi program			[/]
[t set=FngiPrograms]		fngi programs			[/]

[!] token names [/]

[t set=TokensCap]		Tokens				[/]
[t set=Token]			token				[/]
[t set=Tokens]			tokens				[/]

[t set=ValueTokensCap]		Value tokens			[/]
[t set=ValueToken]		value token			[/]
[t set=ValueTokens]		value tokens			[/]

[t set=FunctionTokensCap]	Function tokens			[/]
[t set=FunctionToken]		function token			[/]
[t set=FunctionTokens]		function tokens			[/]

[t set=SyntacticTokensCap]	Syntactic tokens		[/]
[t set=SyntacticToken]		syntactic token			[/]
[t set=SyntacticTokens]		syntactic tokens		[/]

[!] evaluation and execution, and parsed [/]

[t set=Parsed]			parsed				[/]
[t set=Parsing]			parsing				[/]
[t set=Evaluated]		evaluated			[/]
[t set=Evaluating]		evaluating			[/]
[t set=Evaluation]		evaluation			[/]
[t set=Evaluates]		evaluates			[/]
[t set=Execute]			execute				[/]
[t set=Executed]		executed			[/]
[t set=Execution]		execution			[/]

[!] defered, delayed, immediate [/]

[t set=Defered]			defered				[/]
[t set=Delayed]			delayed				[/]
[t set=ImmediateCap]		Immediate			[/]
[t set=Immediate]		immediate			[/]
[t set=Immediately]		immediately			[/]

[!] data structures and data types [/]

[t set=WorkingStack]		working stack			[/]
[t set=Number]			number				[/]
[t set=Numbers]			numbers				[/]
[t set=DelayQueue]		delay queue			[/]
[t set=GlobalDelayQueue]	global delay queue		[/]

[!] spor [/]

[t set=Spor]			spor				[/]
[t set=SporCap]			Spor				[/]

[!] example code ---------------------------------------------	[/]

[t set=ProgramOne]		[c]1[c]				[/]
[t set=ProgramTwo]		[c]2[c]				[/]
[t set=ProgramOneTwo]		[c]1 2[c]			[/]
[t set=ProgramTwelve]		[c]12[c]			[/]
[t set=ProgramHex]		[c]0x10[c]			[/]
[t set=ProgramAdd]		[c]+[c]				[/]
[t set=ProgramOnePlusTwo]	[c]1 + 2[c]			[/]
[t set=ProgramMul]		[c]*[c]				[/]
[t set=Program1Add2Mul4]	[c]1 + 2 * 4[c]			[/]
[t set=ProgramOneTwoAddMulFour]	[c]1 2 + * 4[c]			[/]
[t set=ProgramImm]		[c]imm#[c]			[/]
[t set=ProgramTwoImmThreeFour]	[c]2 imm#3 4[c]			[/]
[t set=ProgramImmThree]		[c]imm#3[c]			[/]
[t set=ProgramThree]		[c]3[c]				[/]
[t set=ProgramFour]		[c]4[c]				[/]
[t set=ProgramFive]		[c]5[c]				[/]
[t set=ProgramParenExample]	[c]5 imm#(1 + 2)[c]		[/]
[t set=ProgramLeftParen]	[c]([c]				[/]
[t set=ProgramRightParen]	[c])[c]				[/]
