[h2]The fngi programmer's manual[/]

[h2]1. Document conventions[/]
[+]
1. Text written in the @FngiLanguage is [c]monospaced[c].
2. The word @ALWAYS implies the sentence is always true; if the sentence is ever false then we have made a mistake.
3. The word @USUALLY implies the sentence is assumed to be true. We write when it is false.
4. The word @SOMETIMES implies the sentence is assumed to be false. We write when it is true.
5. The word @NEVER implies sentence is never true. If the sentence is ever true then we have made a mistake.
[/]

[!]Text in developer comments is for authors.[/] 

[h2]2. Introduction[/]

The @FngiLanguage is an imperative, stack-based programming language. The purpose of this manual is to explain the @Meaning of @FngiPrograms.

[h2]3. @FngiProgramsCap[/]
[+]
1. A @FngiProgram is a @Sequence of @Tokens.
2. The @Meaning of a @FngiProgram is the effect of @Executing the @FngiProgram.
3. To @Execute a @FngiProgram is to @Evaluate the @FngiProgram, then @Execute the @GlobalDelayQueue.
4. To @Evaluate a @FngiProgram is @USUALLY to @Evaluate its @Tokens in order.
[/]

[h2]4. @DelayQueuesCap[/]
[+]
1. The @GlobalDelayQueue is an @DelayQueue.
2. To @Execute an @DelayQueue is to @Execute the @Tokens which have been added to it in the order in which they were added.
[/]

[h2]5. @TokensCap[/]
[+]
1. To @Evaluate a @Token is @USUALLY to add it to an @DelayQueue. That @DelayQueue is @USUALLY the @GlobalDelayQueue.
2. To @Execute a @Token is to do what the @Token @Means.

[!]3. @WhiteSpaceCap is @SOMETIMES used to separate @Tokens.[/]
[!]6. @TokensCap @NEVER contain @WhiteSpace.[/]
[!]7. @WhiteSpaceCap @NEVER has @Meaning.[/]
[/]

[h2]6. @ValueTokensCap[/]
[+]
1. A @ValueToken is a @Token.
2. @ValueTokensCap represent @Numbers.
3. The @Meaning of a @ValueToken is to @Push the @Number that is represents to the @WorkingStack.
[!]4. @ValueTokensCap must be separated by @WhiteSpace when they occur @Sequentially in a @FngiProgram.[/]
[/]

[h3]Examples[/]
[+]
1. The @Token @ProgramOne is a @ValueToken. It @Means @Push the @Number 1 to the @WorkingStack.
2. The @Token @ProgramTwelve is a @ValueToken. It @Means @Push the @Number 12 to the @WorkingStack.
3. The @Token @ProgramHex is a @ValueToken. It @Means @Push the @Number 16 to the @WorkingStack.
4. The @FngiProgram @ProgramOneTwo is made of the @ValueTokens @ProgramOne and @ProgramTwo. The @FngiProgram @ProgramOneTwo @Means @Push the @Number 1 to the @WorkingStack, then @Push the @Number 2 to the @WorkingStack. 
[/]

[h2]7. @FunctionTokensCap[/]
[+]
1. A @FunctionToken is a @Token.
2. If a @Token is @Evaluated after the @Token that follows it is @Evaluated, but not before, then that @Token is @Defered.
3. @FunctionTokensCap are @ALWAYS @Defered.
[/]

[h3]Examples[/]

The @Token @ProgramAdd is a @FunctionToken. The @Token @ProgramAdd @Means @Pull two @Numbers from the @WorkingStack, then @Push their sum to the @WorkingStack. The @FngiProgram @ProgramOnePlusTwo @Means

[+]
1. @PushCap the @Number 1 to the @WorkingStack.
2. @PushCap the @Number 2 to the @WorkingStack (the @Evaluation of @ProgramAdd was @Defered).
3. Execute @ProgramAdd. Now, the @Number 3 is on the @WorkingStack
[/]

The token @ProgramMul is a @FunctionToken. The @Token @ProgramMul @Means @Pull two @Numbers from the @WorkingStack, then @Push their product to the @WorkingStack. The @FngiProgram @Program1Add2Mul4 @Means

[+]
1. @PushCap the @Number 1 to the @WorkingStack.
2. @PushCap the @Number 2 to the @WorkingStack (the @Evaluation of @ProgramAdd was @Defered).
3. Execute @ProgramAdd. Now, the @Number 3 is on the @WorkingStack.
4. @PushCap the @Number 4 to the @WorkingStack (the @Evaluation of @ProgramMul was @Defered).
5. Execute @ProgramMul. Now, the @Number 12 on the @WorkingStack.
[/]

When @FunctionTokens are @Defered @Sequentially, they are @Evaluated in the order opposite to which they were @Defered. The @FngiProgram @ProgramOneTwoAddMulFour @Means

[+]
1. @PushCap the @Number 1 to the @WorkingStack.
2. @PushCap the @Number 2 to the @WorkingStack.
3. @PushCap the @Number 4 to the @WorkingStack (the @Evaluation of @ProgramAdd was @Defered, then the @Evaluation of @ProgramMul was @Defered).
4. Execute @ProgramMul. Now, the @Number 8 is on the @WorkingStack.
5. Execute @ProgramAdd. Now, the @Number 9 is on the @WorkingStack.
[/]

[!]Immediate and delayed definitions do not belong here. Find a way to explain syntactic tokens without resorting to these definitions.[/]
[h2]8. @ImmediateCap and @Delayed @Execution[/]
[+]
1. If a @Token is not added to an @DelayQueue when it is @Evaluated, but is @Executed when it is @Evaluated then we say that @Token is @Immediate.
2. If a @Token is added to an @DelayQueue when it is @Evaluated, but is not @Executed when it is @Evaluated then we say that @Token is @Delayed.
3. @TokensCap are @USUALLY @Delayed.
[/]

[h3]Examples[/]
A deeper level of detail to our explanation of the behavior of the @FngiProgram @ProgramOneTwo would be:
[+]
1. The @Token @ProgramOne is @Evaluated. It undergoes @Delayed @Execution and is added to the @GlobalDelayQueue.
2. The @Token @ProgramTwo is @Evaluated. It undergoes @Delayed @Execution and is added to the @GlobalDelayQueue.
3. Now that all @Tokens have been @Evaluated, we dequeue the @Token @ProgramOne from the @GlobalDelayQueue. The @Token @ProgramOne is @Executed, and the @Number 1 is pushed to the @WorkingStack.
4. We dequeue the @Token @ProgramTwo from the @GlobalDelayQueue. The token @ProgramTwo is @Executed, and the @Number 2 is pushed to the @WorkingStack.
[/]
To @Execute a @Token @Immediately, the @ProgramImm @Token is prepended to that @Token. The @ProgramImm @Token is @ALWAYS @Executed @Immediately. For example, when the @FngiProgram @ProgramTwoImmThreeFour is @Executed, the following operations occur in order:
[+]
1. The @Token @ProgramTwo is @Evaluated. It undergoes @Delayed @Execution and is added to the @GlobalDelayQueue.
2. The @Token @ProgramImm is @Executed @Immediately. It causes the @Token @ProgramThree to be @Executed @Immediately. The @Number 3 is pushed to the @WorkingStack.
3. The @Token @ProgramFour is @Evaluated. It undergoes @Delayed @Execution and is added to the @GlobalDelayQueue.
4. The @Token @ProgramTwo is dequeued from the @GlobalDelayQueue and @Executed. The @Number 2 is pushed to the @WorkingStack.
5. The @Token @ProgramFour is dequeued from the @GlobalDelayQueue and @Executed. The @Number 4 is pushed to the @WorkingStack.
[/]

[h2]9. @SyntacticTokensCap[/]

A @SyntacticToken is a kind of @Token. @SyntacticTokensCap are @ALWAYS @Executed @Immediately. @SyntacticTokensCap can be built-in or user defined. The general purpose of @SyntacticTokens is to implement syntactic constructs. We have already seen an example of one @SyntacticToken: the @ProgramImm @Token. The @ProgramImm @Token triggers @Immediate @Execution of the @Token which follows it.

The @Token @ProgramLeftParen is a @SyntacticToken. When the @Token @ProgramLeftParen is @Executed, it @Evaluates all subsequent @Tokens until it encounters the @Token @ProgramRightParen. In effect, this causes all sequences of @Tokens which are parenthesized to be treated as a single @Token in a number of contexts.

For example, consider the @FngiProgram @ProgramParenExample. The @Token @ProgramFive undergoes @Delayed @Execution. The @Token @ProgramImm causes the token @ProgramLeftParen to be @Executed @Immediately. The @Token @ProgramLeftParen @Evaluates @ProgramOnePlusTwo (stopping at @ProgramRightParen) and triggers their @Immediate @Execution as well. The result is that the @Number 3 is pushed to the @WorkingStack, then the @Number 5 is pushed to the @WorkingStack.

[!]Explain [c]()[c], [c]+(1 2)[c] and [c]1 2 +()[c] in this section. Correct grammar and spelling mistakes using automated checker.[/]

[!] glossary -------------------------------------------------	[/]


[t set=ALWAYS]			[i]always[i]			[/]
[t set=USUALLY]			[i]usually[i]			[/]
[t set=SOMETIMES]		[i]sometimes[i]			[/]
[t set=NEVER]			[i]never[i]			[/]

[!] fngi related [/]

[t set=Fngi]			fngi				[/]
[t set=FngiLanguage]		fngi language			[/]
[t set=FngiEnvironment]		fngi environment		[/]
[t set=FngiInterpreter]		fngi interpreter		[/]

[t set=FngiProgramsCap]		Fngi programs			[/]
[t set=FngiProgram]		fngi program			[/]
[t set=FngiPrograms]		fngi programs			[/]

[!] token names [/]

[t set=TokensCap]		Tokens				[/]
[t set=Token]			token				[/]
[t set=Tokens]			tokens				[/]

[t set=ValueTokenCap]		Value token			[/]
[t set=ValueTokensCap]		Value tokens			[/]
[t set=ValueToken]		value token			[/]
[t set=ValueTokens]		value tokens			[/]

[t set=FunctionTokenCap]	Function token			[/]
[t set=FunctionTokensCap]	Function tokens			[/]
[t set=FunctionToken]		function token			[/]
[t set=FunctionTokens]		function tokens			[/]

[t set=SyntacticTokensCap]	Syntactic tokens		[/]
[t set=SyntacticToken]		syntactic token			[/]
[t set=SyntacticTokens]		syntactic tokens		[/]

[!] evaluation and execution, and parsed [/]

[t set=Parse]			parse				[/]
[t set=Parsed]			parsed				[/]
[t set=Parsing]			parsing				[/]

[t set=Evaluate]		evaluate			[/]
[t set=Evaluated]		evaluated			[/]
[t set=Evaluating]		evaluating			[/]
[t set=Evaluation]		evaluation			[/]
[t set=Evaluates]		evaluates			[/]

[t set=Execute]			execute				[/]
[t set=Executed]		executed			[/]
[t set=Execution]		execution			[/]
[t set=Executing]		executing			[/]

[!] defered, delayed, immediate [/]

[t set=DeferedCap]		Defered				[/]
[t set=Defered]			defered				[/]
[t set=Delayed]			delayed				[/]
[t set=ImmediateCap]		Immediate			[/]
[t set=Immediate]		immediate			[/]
[t set=Immediately]		immediately			[/]

[!] data structures and data types [/]

[t set=WorkingStack]		working stack			[/]
[t set=Push]			push				[/]
[t set=PushCap]			Push				[/]
[t set=Pull]			pull				[/]
[t set=Number]			number				[/]
[t set=Numbers]			numbers				[/]
[t set=DelayQueuesCap]		Execution queues		[/]
[t set=DelayQueue]		execution queue			[/]
[t set=GlobalDelayQueue]	global execution queue		[/]

[!] spor [/]

[t set=Spor]			spor				[/]
[t set=SporCap]			Spor				[/]

[!] misc [/]

[t set=Sequence]		sequence			[/]
[t set=Sequentially]		sequentially			[/]
[t set=Subsequent]		subsequent			[/]
[t set=WhiteSpace]		white space			[/]
[t set=WhiteSpaceCap]		White space			[/]
[t set=Means]			means				[/]
[t set=Meaning]			meaning				[/]
[t set=String]			string				[/]

[!] example code ---------------------------------------------	[/]

[t set=ProgramOne]		[c]1[c]				[/]
[t set=ProgramTwo]		[c]2[c]				[/]
[t set=ProgramOneTwo]		[c]1 2[c]			[/]
[t set=ProgramTwelve]		[c]12[c]			[/]
[t set=ProgramHex]		[c]0x10[c]			[/]
[t set=ProgramAdd]		[c]+[c]				[/]
[t set=ProgramOnePlusTwo]	[c]1 + 2[c]			[/]
[t set=ProgramMul]		[c]*[c]				[/]
[t set=Program1Add2Mul4]	[c]1 + 2 * 4[c]			[/]
[t set=ProgramOneTwoAddMulFour]	[c]1 2 + * 4[c]			[/]
[t set=ProgramImm]		[c]imm#[c]			[/]
[t set=ProgramTwoImmThreeFour]	[c]2 imm#3 4[c]			[/]
[t set=ProgramImmThree]		[c]imm#3[c]			[/]
[t set=ProgramThree]		[c]3[c]				[/]
[t set=ProgramFour]		[c]4[c]				[/]
[t set=ProgramFive]		[c]5[c]				[/]
[t set=ProgramParenExample]	[c]5 imm#(1 + 2)[c]		[/]
[t set=ProgramLeftParen]	[c]([c]				[/]
[t set=ProgramRightParen]	[c])[c]				[/]
