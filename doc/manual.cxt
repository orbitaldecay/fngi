[h1]The fngi programmer's manual[/]

[h2]Document conventions[/]

Words and phrases with special meaning are [b]bolded[b] the first time they are used. Fngi code is always [c]monospaced[c]. Text that concerns details of fngi language implementation that may not be relevant to a casual reader are [i]italicized[i]. [!]Words in developer comments are notes for authors.[/]

[h2]Introduction[/]

The [b]fngi language[b] is a stack-based programming language. The semantics of the fngi language are described in terms of stack manipulation. When we say [b]fngi[b], we are refering to the fngi langage. The [b]fngi environment[b] is a REPL for the [b]fngi interpreter[b].

[h3]Tokens[/]

A [b]fngi program[b] is a program written in the fngi language. Fngi programs are composed of [b]tokens[b]. A token is the smallest unit of a fngi program. Tokens are typically [b]evaluated[b] from left to right and from top to bottom.

[!]I am writing this for the purposes of explaining how fngi programs are executed. From that perspective, we are interested in explaining the order of execution of tokens. Let me know if you think this is at all unclear.[/]

Whitespace is sometimes used to delineate between tokens, but has no semantic value.

[h3]Value tokens[/]

A [b]value token[b] is a kind of token. When a value token is executed, the number represented by the value token is pushed onto the [b]working stack[b]. The token [c]1[c] is a value token. When executed, it pushes the number 1 onto the working stack.

Furthermore, [c]1 2[c] is a fngi program. It consists of two value tokens: [c]1[c] and [c]2[c]. When this program is executed, the number 1 is pushed onto the working stack, then the number 2 is pushed onto the working stack. The tokens [c]1[c] and [c]2[c] could be separated by any whitespace to delineate between them.

Value tokens can also be written in hexadecimal. The token [c]0x10[c] is a token token. When [c]0x10[c] is executed, the number 16 is pushed onto the working stack.

[h3]Function tokens[/]

A [b]function token[b] is a kind of token. Function tokens in fngi are evaluated differently than functions in many other stack-based languages. Rather than being evaluated when they are encountered, function token evaluation is [b]deferred[b] until after the next token is evaluated.

The token [c]+[c] is a function token. When [c]+[c] is executed, two numbers are popped from the working stack, then their sum is pushed to the working stack. The execution of the program [c]1 + 2[c] performs the following operations in order:

[+]
1. Push the number 1 onto the working stack.
2. Push the number 2 onto the working stack (the evaluation of [c]+[c] was deferred).
3. Finally, execute [c]+[c].
[/]

When this is performed, the number 3 is left on the working stack. Notice how this allows functions of arity 2 to be written in infix notation.

The token [c]*[c] is a function token. When [c]*[c] is executed, two numbers are popped from the working stack, then their product is pushed to the working stack. The execution of the program [c]1 + 2 * 4[c] performs the following operations in order:

[+]
1. Push the number 1 onto the working stack.
2. Push the number 2 onto the working stack (the evaluation of [c]+[c] was deferred).
3. Execute [c]+[c] leaving the number 3 on the working stack.
4. Push the number 4 onto the working stack (the evaluation of [c]*[c] was deferred).
5. Execute [c]*[c] leaving the number 12 on the working stack.
[/]

When multiple functions tokens are deferred successively, they are evaluated in the opposite order in which they were deferred. The execution of the program [c]1 2 + * 4[c] (a program which you would probably not want to write) performs the following operations in order:

[+]
1. Push the number 1 onto the working stack.
2. Push the number 2 onto the working stack.
3. Push the number 4 onto the working stack (the evaluation of [c]+[c] was deferred, then the evaluation of [c]*[c] was deferred).
4. Execute [c]*[c], leaving the number 8 on top of the working stack.
5. Execute [c]+[c], leaving the number 9 on top of the working stack.
[/]

[h3]Immediate and delayed execution[/]

When a token is evaluated, that token is either executed or added to a [b]delay queue[b] for later execution. We call this [b]immediate[b] and [b]delayed[b] execution, respectively.

When a token is executed immediately, execution occurs before the next token is evaluated.

When a token undergoes delayed execution, that token is added to a delay queue. To execute a delay queue is to execute the tokens in that delay queue in the order in which they were added. The [b]global delay queue[b] is the delay queue to which tokens are added by default. The global delay queue is executed after all tokens have been evaluated.

[i]In the standard implementation, the delay queue is a [b]spor[b] buffer. Spor is the internal bytecode of the fngi language. In other implementations, the delay queue could be a native code buffer, or even a literal queue of fngi tokens. This is all implementation specific. For the purposes of documentation, we've chosen to simply call it a delay queue.[i]

All of the examples of tokens and fngi programs that we have seen thus far have used delayed execution. Value tokens and function tokens use delayed execution. A deeper level of detail to our explanation of the behavior of the fngi program [c]1 2[c] would be:

[+]
1. The token [c]1[c] is evaluated. It undergoes delayed execution and is added to the global delay queue.
2. The token [c]2[c] is evaluated. It undergoes delayed execution and is added to the global delay queue.
3. Now that all tokens have been evaluated, we dequeue the token [c]1[c] from the global delay queue. The token [c]1[c] is executed, and the number 1 is pushed to the working stack.
4. We dequeue the token [c]2[c] from the global delay queue. The token [c]2[c] is executed, and the number 2 is pushed to the working stack.
[/]

To execute a token immediately, the [c]imm#[c] token is prepended to that token. For example, when the program [c]2 imm#3 4[c] is run, the following operations occur in order:

[+]
1. The token [c]2[c] is evaluated. It undergoes delayed execution and is added to the global delay queue.
2. The token [c]imm#[c] causes the token [c]3[c] to be executed immediately. Prior to evaluating the token [c]4[c], the number 3 is pushed to the working stack.
3. The token [c]4[c] is evaluated. It undergoes delayed execution and is added to the global delay queue.
4. The token [c]2[c] is dequeued from the global delay queue and executed. The number 2 is pushed to the working stack.
5. The token [c]4[c] is dequeued from the global delay queue and executed. The number 4 is pushed to the working stack.
[/]

[h3]Syntactic tokens[/]

A [b]syntactic token[b] is a kind of token. Unlike value tokens and function tokens, syntactic tokens are executed immediately by default. Syntactic tokens can be built-in or user defined. The general purpose of syntactic tokens is to implement syntactic constructs. We have already seen an example of one syntactic token: the [c]imm#[c] token. The [c]imm#[c] token triggers immediate execution of the token which follows it.

The token [c]([c] is a syntactic token. When the token [c]([c] is executed, it evaluates all subsequent tokens until it encounters the token [c])[c]. In effect, this causes all sequences of tokens which are parenthesized to be treated as a single token in a number of contexts.

For example, consider the program [c]5 imm#(1 + 2)[c]. The token [c]5[c] undergoes delayed execution. The token [c]imm#[c] causes the token [c]([c] to be executed immediately. The token [c]([c] evaluates [c]1 + 2[c] (stopping at [c])[c]) and triggers their immediate execution as well. The result is that the number 3 is pushed to the working stack, then the number 5 is pushed to the working stack.

[!]Explain [c]()[c], [c]+(1 2)[c] and [c]1 2 +()[c] in this section. Correct grammar and spelling mistakes using automated checker.[/]
